# Part 1:プログラミンとは（理論・マインド編）

Wikipedia の「プログラミング」の項目には、は次のように書かれている。

>コンピュータのプログラミング(英：Programming)とは、コンピュータプログラムを作成する事により、人間の意図した処理を行うようにコンピュータに指示を与える行為。まず、そのプログラムの目的、さらには「本当に解決したい問題は何なのか」ということについて十分な検討が必要である。

前半部分の説明はすんなりと入ってくるが、後半部分の説明はなかなか哲学的である。あなたは「本当に解決したい問題は何なのか」を理解していないことなど無いだろう･･･と思うかもしれないが、実は「本当に解決したい問題が何なのか」を理解しないまま開発が行われたシステムの例は山ほどある。特に開発規模が大きくなるにつれてこのリスクが高まる。

では一体全体なぜこのようなことが起こってしまうのだろうか？　どのようにすればこのリスクを低減できるだろうか？　それを理解するためには、少々回り道をしてしまうかもしれないが、このミスマッチ問題の歴史的背景について紐解いていくことにしたい。


## なぜプログラミングするのか？（目的）

これまた、いきなり哲学的な問いかけで申し訳ないが、プログラミングを行う目的として、次の３つが上げられると筆者は考える。

- 問題を解決するため
- 問題を理解するため
- 問題を楽しむため

それぞれについて、もう少し深掘りしていこう。ただし、最後のものについては本講義で対象としないので、自分で考察してみて欲しい。

### 問題を解決するためのプログラミング

「問題を解決する」はプログラミングの最も主たる目的であろう。コンピュータという決められた手続きを高速かつ正確に処理できる機械を用いて、何らかの問題を自動的に間違いなく解決したいというのが最も大きなニーズであるからである。

その場合、「本当に解決したい問題」は自分の解決したいニーズに決まってるじゃないか･･･とそう思うかもしれないが、ところがどっこい、ここには大きな落とし穴が待っている場合が多い。

例えばこんな場合を考えてみよう。

いま、あなたは多くの手順が必要な複雑な作業をなんとか自動化したいと思っているとする。そして、そのためにプログラミングを行うべきだと考えていたとしよう。あなたの持っているニーズは「それぞれの手順を間違いなく、高速に実施すること」である。少なくともそれに異論はないだろう。

しかし、ちょっと待って欲しい。「本当に解決すべき問題」は、高速で間違いなくその処理をすることなのだろうか？　たとえば、そのプロセスの中には、もっと合理的に出来る手順とかは含まれていないだろうか？あるいは、そもそもそのような手続きが必要でない仕組みを作るということでは無いだろうか？　いわゆる合理化や最適化と呼ばれる範疇である。

真の意味でプログラミングを行うということは、単なる高速化を行うということではなく、その周辺の問題を俯瞰し、本来あるべきことはどういうことなのか？について考え、それをシステムとして落とし込んでいくという高度な作業であるのだ。ある意味、最も適切なゴールを見つける、あるいは定義する作業であるとも言える。

このような抽象度の高い作業を「設計」(Software Design)と呼び、それに従ってプログラミングする具体的な作業を「実装」(Implementation) と喚び、一般的には両者は別のスキルであるとされる。特に日本のソフトウェア業界では、「設計」をするのが偉い人（SE）で「実装」は下請けのプログラマーにやらせる･･･といった風潮がまかり通っている。だから日本のソフトウェア業界は欧米に負けるのだ。

本来、適切に実装出来るのは、設計の意図をきちんと捉えられるからこそであり、逆に、コンピュータの仕組みや動作を実装レベルで理解できるからこそ適切な設計が出来るのである。つまり、設計と実装は表裏一体、陰と陽の関係なのである。どっちが偉いとか、そんなことはなく、どちらも重要なのだ。

実際、過去の偉人はどちらも達人級で出来ている。有名どころだけでも、ビル・ゲイツ、セルゲイ・ブリン、ラリー・ペイジ、ジェフベゾス、マーク・ザッカーバーグ、など枚挙にいとまがない。偉大なデベロッパーは、設計も実装も何もかも全て自分でやれる人なのである。

このように、プログラミングとは本来は非常に対象とする範囲が広い概念であるのだが、なぜか「実装」部分、とりわけプログラムを書く作業だけを捉えられることが多い。実際には、ソフトウェア・エンジニアリング（Software Engineering) という言い方がもっともしっくりくるのではないだろうか。あるいは、コーディング（Coding) という言い方も最近は良くされる。

いずれにせよ、プログラミングとは「本当に解決したい問題は何なのか」を明らかにする作業でもあり、その具体的な方法をコンピュータが理解できる内容に適切に変換していく作業であると言える。

特に、問題を解決するためのプログラミングにおいては、いかに自分達が求めるゴールを適切に設定できるかが、そのプログラミングが成功するかどうかを決めると言っても過言ではない。


### 問題を理解するためのプログラミング

一方、自分達が最終結果に対するゴールが適切に設定できない場合もある。

たとえば、一つひとつの要素については十分理解できるが、それぞれが複雑に作業した場合、どのような挙動となるかが容易に予測出来ない問題などである。

このように、様々な要素が複雑に絡み合った場合にどのような結果を生み出すか簡単に予測できない場合などは、問題自体を理解するためにプログラミングを行うことは非常に有効である。これがまさしく、理論、実験に次ぐ「第三の科学」とも呼ばれるコンピュータ・シミュレーションの実施内容であり目的である。

私たちが取り扱う炉物理計算も、元はといえばこの部類に入ると言えるだろう。特にモンテカルロ計算はまさしくこの典型例である。そもそもモンテカルロ法とは、元々は中性子が物質中を動き回る様子を探るためにスタニスワフ・ウラムが考案し、ジョン・フォン・ノイマンにより命名された手法と言われている。

このように、取り扱いたい問題の概念モデルを作成し、それをコンピュータが取り合え使える数学的モデルや数値計算モデルに落とし込むという、モデリング＆シミュレーション (Modelling & Simulation)という考え方が広く一般的になってきている。

この際に、意図したとおりに動作するかを確認すること（検証）や、期待される結果が得られることを確認すること（妥当性確認）を適切に行うことが大変重要である。ただし、妥当性確認については、直接的に行えない場合が多い。というのも、そもそもよく分からない現象を理解するためにシミュレーションを行うのであって、予測が正しいかどうかを直接的に確かめることが出来ないのが普通だからである。例えば、シビアアクシデント・シミュレーションなどはその端的な例である。このような場合、小規模な体系で妥当性確認を行うのが一般的である。しかしながら、大規模体系と小規模体系ではスケーリング則 (Scaling Law)が成り立たない場合も多いため、妥当性確認の方法には注意が必要である。

検証(Verification)と妥当性確認(Validation)は合わせて V&V と喚ばれ、シミュレーションやそれを実現するためのソフトウェアの信頼性を担保するために重要な役割を担っているが、本講義での範囲を超えるので詳細は割愛する。興味のある読者は「モデリング＆シミュレーション」「Verification & Validation」などでググってみて欲しい。


## どのようにプログラミングするのか？（手段）

プログラミングの目的が明確になったとして、実際にどのような方法でプログラミングを行えば良いのだろうか？

これを一言で伝えるのは極めて難しい問題だ。体系立てて伝えることは非常に難しく、どこから手をつければ良いのか困ってしまうからだ。

以下では、あまり整理された内容でなくなる可能性もあるが、筆者が持っている知識と経験をできるだけアウトプットすることを試みる。何度も読んでみて欲しい。

## オブジェクト指向のすすめ

筆者がオブジェクト指向という概念に出会ったのは、かれこれ20年以上も前のことである。Smalltalk や Object Pascal について書籍を通じて学んだが、実際のプログラミングを体験したのは C++ が初めてであった。（その後、後に MacOS X のベースとなった NeXTStep 上で Objective-C を体験）

当時、X68000 という SHARP製の「パーソナルワークステーション」上で稼働する Ko-Window System というウィンドウシステムがあった。(ちなみに、当時は高嶺の花であった UNIXワークステーション上で動作する、X-Window System を参考にして作られたものである。これと同じ世界観を楽しめるという意味で Ko-Window は画期的で、一部のマニアの間で大流行した･･･と思う）筆者は Ko-Window 上で動作するとあるアプリケーションをC言語で製作していたのだが、その先輩が C++ のクラスライブラリも作っていたので試しに使ってみた。するとどうだろう、これまで大変だったウィンドウや各コンポーネントの管理が劇的に簡単になったのだった。これは大変な衝撃であった。

これまでの考え方と180度異なると言っても過言では無いオブジェクト指向の考え方は、まさしくコロンブスの卵的な発想であった。そして、いったんオブジェクト指向の考え方に慣れ親しむと、これまでは一体全体どのようにしてプログラムを書いてきたのだろうか･･･？と思えてしまうほど、自然な考え方になってきたのであった。

これまでのプログラムの作り方は、たとえて言うならば、設計者は全知全能の神となる必要があった。細部のロジックや個々の変数、関数の定義やその副作用（関数戻り値以外の影響）について、事細かく把握しておく必要があったからである。しかし、オブジェクト指向ではプログラムを複数のコンポーネントに分割し、互いの内部情報は原則的に参照できない。その代わり、それぞれがメッセージをやりとりしながら協調して動作する。こうして、ボトムアップ的なアプローチと各階層における適切な抽象化により、全体システムとして把握することが容易になったのである。

実は、オブジェクト指向の概念は身の回りにたくさん見つけることが出来る。というよりは、オブジェクト指向の考え方自体が、世の中の構造をモデリングした結果であると言えるだろう。

たとえば、ゲームのなかのキャラクターを例に考えてみよう。ここでは、往年の名作であるドラゴンクエスト（通称ドラクエ）のスライムを例にあげてみる。ゲーム中にはたくさんのスライムが登場するが、それぞれの個体は異なる状態を持っている。ただし、スライムという種類は同じなので基本的な特性は同じだから、動作内容もひとくくりに定義できると便利だろう。

この定義全体のことをオブジェクト指向ではクラス(Class)と呼び、各個別の動作に関する関数定義のことをメソッド (Method)と呼ぶ。また、異なる状態を持つそれぞれの個体のことをインスタンス (Instance)やオブジェクト(Object)と呼んでいる。（オブジェクトという呼び方は、オブジェクト指向と紛らわしいので、以後はインスタンスで統一する）

それぞれのスライム・インスタンスは、保持する内容は異なるが、処理はすべて同じだ。たとえば、スライム・クラスにて、「生まれる」「移動する」「闘う」「防御する」「ダメージを受ける」「死ぬ」などの基本動作（メソッド）を定義しておけば、スライムインスタンスを生成（「生まれる」というメソッドを呼び出す）した後は、それぞれのメソッドを呼び出せば、期待される動作をするだろう。この時、メソッドを呼び出した方は、その内部動作がどのように実現されているかは関知しないという点が重要である。逆に言うと、それぞれのスライム・インスタンスの内部状態(インスタンス変数)は、外部からは見えないように隠蔽しておくべきである。もし外部から内部変数を確認したい場合は、それを取得するためのメソッド(getter メソッド）を準備するというのが基本的な考え方である。

内部変数を自由に参照できないなんて、なんてオブジェクト指向は面倒なんだ･･･と思ったのであれば、それは早計だ。この、メソッドのインターフェース（インプット、アウトプット、副作用）をきちんと定義・公開することによって、内部の状態や実現方法に依存することがなくなるのである。つまり、互いの独立性が高まることで、複雑な処理を行う大規模システムを高い保守性を維持したまま実現することが容易になる･･･というわけだ。

もし仮に、それぞれの状態についても明示的に把握・管理ができたとうしよう。そんなとき、一部のモジュールの内部状態の管理方法を変更する必要がでたとしたら･･･一体全体どうなるだろうか？　このようなことは、複数人が関わるプロジェクトでは簡単に起こり得ることだろう。うまく行けば、コンパイルが出来ないとか動作しないという、明らかなエラー状態を生み出すことができる。しかし一番厄介なのは、一見問題なく動いているように見えるが、特定の条件のときにエラーが起こるという、非常に再現性に乏しいバグが発生する場合なのだ。こんな状況のデバッグ作業は本当に大変だろう。想像するだけでもゾッとしてしまう。

こういった非オブジェクト指向なアプローチでは、管理すべき対象が増えれば増えるほど、内部構造が非常になれば複雑になるほど各パートの結合度が高まり、互いに影響を与える可能性が高くなってしまうのである。確かに、関数定義を行い、構造化プログラミングを適切に行うことで、ある程度の規模までであれば問題の発生を抑制することができるが、その分だけ管理コストは増加していく。筆者の体験で言うと、ソースコードが1万行を超える規模あたりから管理コストは飛躍的に高まっていくだろう。

他にも、オブジェクト指向アプローチにおいては、継承(inheritance) や多相性(Polymorphism) という重要な概念がある。どちらもオブジェクト指向のメリットを享受するためには避けて通れない内容であるが、時間の関係から本講義では取り扱わない。興味のある読者はオブジェクト指向プログラミングに関する書籍等を読んでみて欲しい。


## モデリングのすすめ

どんな世界でも、成功するものと失敗するものがある。偶然による場合もあるが、大抵の場合、それぞれにはそれなりの理由があるものだ。このため、成功する確率を高めるためには、過去に成功した事例を研究し、その中から成功に至った要因を分析し、それを再現すれば良い。この基本的な戦略によって実践されるのがモデリング (Modeling) であり、あらゆる分野で基本的なメソッドとして活用されている。

ソフトウェア開発においても、このモデリングが非常に有効である。ここでは、モデリングすべき大きな二つの概念を紹介しよう。


### デザインパターンとアンチパターン

前節において、プログラミングとは「本当に解決したい問題は何なのか」を明らかにする作業でもあり、その具体的な方法をコンピュータが理解できる内容に適切に変換していく作業であると述べた。

この作業については、構造化プログラミングといった基本的な考え方はあったが、それほど体系化されたものはなかった。その後、オブジェクト指向アプローチが一般的になるにつれて、成功するソフトウェア開発には一定のパターンがあることを見いだした人々がいた。彼らは、それを「デザインパターン」と呼び、ソフトウェア設計のノウハウを再利用しやすいようにカタログ化したのである。これは、



## アジャイル開発




## ベストプラクティス

### KISSの法則

### 車輪の再発明をしない

### 名前重要

### DRY (Don't Repat Yourself) 原則

### 設定より規約 (Convention over Conviguration)



## ピットフォール

### プログラムのライフサイクル

### ソフトウェアの品質保証

### レバレッジ戦略

### 自己投資の重要性



## 参考文献
