# Part 2: 炉物理プログラミング (実践・スキル編)

では、いよいよ本題のテーマである炉物理プログラミングを始めてみる。

いきなり実践に入る前に、少しだけ準備運動をしておこう。

事前課題において Python言語の基礎的な知識は習得しているはずだが、少しだけおさらいしておく。

## Python言語について

Python言語は、いま最も使われているスクリプト言語の一つだと言って良いだろう。特に、最近は機械学習・深層学習がとても注目されているが、その関連でも Pythonは非常によく使われている。

また、欧米の高等教育現場において Python の利用率は非常に高い。少し前は MATLAB がメジャーだったが、今は完全に Python が追い越したと言っても良いだろう。このように、Python は教育現場や実プロジェクトで多く用いられているため、是非とも使いこなせるようになっておきたい。

プログラミングのエッセンスはプログラミング言語に依存しない。また、プログラミング言語は互いに影響をうけあいながら発展している。したがって、一つのプログラミング言語をマスターしておけば、他の言語の習得は比較的容易に行える。このことからも、まだ本格的にプログラミングを学習していなのであれば、Python を最初に学習することをお薦めする。


### 必須文法・構文

Python の文法は非常にシンプルだ。また、構文（スコープ）がインデントにより決定されるという点が特徴で、この部分は賛否両論があるのだが、なれてしまえばそれほど気にはならない。インデントと上手く付き合うためには、「Python モード」があるエディタを活用する方が良いだろう。

#### 変数・演算

これといって特徴はない。普通に使える。ただし、インクリメント・デクリメント演算子(++, --) は存在しないので C++使いの人は要注意。

```Python
hoge = 10
page = hoge * 2.0
page += hoge
```

#### リスト・辞書・タプル

Pythonでは、配列は リスト (list)で、ハッシュは辞書(dic) という型で実現している。タプル(Tuple)はPython独自の型で、値の変更が不可能なリストと理解すれば良い。リストはブラケット(bracket)、辞書はブレース({})、タプルは括弧(())にて表記する。リストやタプルについては、一部を切り出す「スライシング (slicing)」が可能であり、上手く使うと実装が劇的に簡単になる場合がある。

```Python
the_list = [1,2,3,4,5,6]

the_first  = the_list[0]     # 1
the_last   = the_list[4]     # 5
the_last2  = the_list[-1]    # 6
the_slice  = the_list[1:4]   # [2,3,4] 
the_slice2 = the_list[1:4:2] # [2,4]


the_dic = {'hoge':1, 'page':2, 'hogepage':3}

hoge = the_dic['hoge']           # 1
the_keys = list(the_dic.keys())  # ['hoge', 'page', 'hogepage']

the_tuple = (1,2,3)
the_first = the_tuple[0]     # 1
the_slise = the_tuple[0:2]   # (1,2)
```


#### 判断

if文の最後のコロン(:)を忘れないようにすること。また、if文の条件部分には括弧は不要である。（括弧をつけても文法上問題はないが、使わないのがPython流）　なお、「後置if」はないのが Rubyist には残念だが、Python のポリシーから考えると仕方がないところだ。

```Python
if hoge == page:
    print("hoge is the same as page!")
elif hoge > page:
    print("hoge is greater than page!")
else:
    print("hoge is smaller than page!")
```

#### 繰り返し

繰り返しには For構文とWhile構文を知っていたら十分だろう。

```Python
the_list = [1,2,3,4,5,6]
for i in the_list:
    print(i)

total = 0
idx = 1
while idx < 5:    # done when idx in [1,2,3,4]
    total += the_list[idx]
    idx += 1
print(idx,total)  # 5, 14 == 2+3+4+5

while True:
    if total > 20:
        break     # 直近のループを抜け出す
    print(total)
    total += 1
```

#### 関数定義

関数定義も簡単である。名前付き引数(named parameter)や省略値を用いることが出来るので便利だ。また、戻り値にリスト、タプル、オブジェクトを用いることで、複雑な戻り値を返すことができる。関数の役割は与えられた引数に対する関数値を返すことである。よってそれ以外の効果を「副作用(side effect)」と呼ぶ。例えば、画面に値を表示したり、データベースに記録したりするなどがある。副作用といっても、決して悪影響を及ぼすことではないので注意すること。


```Python
def die_risk (weight, food, drink="coke"):
    factor = 1.0
    if food == "salad":
        factor = 0.5
    elif food == "pizza":
        factor = 1.5
    
    if drink=="coke":
        factor *= 2.0
    
    the_risk = (weight-50) * factor
    print("Die risk: ", the_risk)   # 副作用 (side effect)

    return the_risk


die_risk(60, "salada", "water") 
die_risk(food="pizza", weight=70)
die_risk(food="humberger", drink="coke", weight=100)
```


#### モジュール
他のプログラムから再利用できるようにしたファイルのことを「モジュール」という。
モジュールには、自分でPythonを用いて作成する「通常モジュール」、あらかじめ装備されている「組み込みモジュール」、C言語など他の言語で開発された「拡張モジュール」に分類される。モジュールをパッケージとしてまとめ、「外部ライブラリ」として公開されているので、どんなライブラリがあってどのように使えるのかを知っているかどうかで効率が劇的に変わる。欲しいライブラリは、大抵の場合、既に誰かによって開発されている。車輪の再発明を行わないためにも、事前に入念な調査が必要だ。

モジュールの読み込みは import 文を用いて行う。

```Python
import random      # 乱数に関する組み込みモジュール
from math import sin, cos   # math モジュールから sin, cos 関数を使う

random.random()    # 0.9065161930701089
sin(0), cos(0)     # (0.0, 1.0)
```


#### クラス定義

Python におけるクラスの定義は、他の言語とよく似ており、特に難しいところは無いだろう。メソッドの定義において、第一引数が自分自身を現すselfとなる点に注意。(C++のthisに相当） なお、コンストラクタメソッドは \_\_init\_\_ である。 内部変数にアクセスする場合には、かならず self が必要なので注意が必要だ。

```Python
import random

class Worker:
    
    def __init__(self, initial_energy=10):
        self.energy = initial_energy

    def eat(self, the_energy):
        print("Got energy {:.1f}".format(the_energy))
        self.energy += the_energy

    def sleep(self, duration):
        print("Seeep {:.1f} hours".format(duration))
        self.energy += 5.0 * duration
    
    def work(self, duration):
        print("Work  {:.1f} hours".format(duration))
        self.energy -= 10.0 * duration
        
    def get_energy(self):
        return self.energy
    
    def is_alive(self):
        if self.energy > 0:
            return True
        else:
            return False

      
guy = Worker()

ENERGY_UNIT = 10
SLEEP_UNIT = 8
WORK_UNIT  = 8

while True:
    feed_energy = random.random() * ENERGY_UNIT
    guy.eat(feed_energy)

    sleep_duration = random.random() * SLEEP_UNIT
    guy.sleep(sleep_duration)

    work_duration = random.random() * WORK_UNIT
    guy.work(work_duration)

    if guy.is_alive():
        print("   Still Alive: {:.2f}".format(guy.get_energy()))
    else:
        print("   DEAD: {:.2f}".format(guy.get_energy()) )
        break
```

実行例はこちら。なお、乱数を使っているので、実行毎に結果は異なる。これも一種のシミュレーションと言えるか!?

~~~
Got energy 9.3
Seeep 6.8 hours
Work  4.4 hours
   Still Alive: 9.83
Got energy 4.7
Seeep 7.5 hours
Work  5.5 hours
   DEAD: -2.62
~~~


## １群1次元拡散ソルバーの実装

ではいよいよ本題に入ろう。本節では、炉物理計算で最も簡単な問題に該当する、1群1次元拡散方程式を解くプログラムを作っていく。計算コードというほど大げさなものでは無いが、ここでは敢えてそういう言い方をしよう。

さて、一言に1群1次元拡散計算コードといえど、解くための数値解法や実装方法はたくさんある。それらを列挙するのは本講義の本題では無いため、いきなり結論を述べるが、ここでは応答行列法に基づくソルバーを実装していくことにする。

なお、拡散方程式の応答行列法に基づく求解については、夏期セミナーテキストの千葉先生による解説を参照されたい。


### Step0: 全体構想を練る

計算コードであれ、何であれ、システムを構築する際には全体構成を考えておく必要がある。この際のポイントを挙げておこう。

  1. システムの目的を明確にする
  2. システムを幾つかのサブシステムに分割する
  3. 上記の 1. と 2. を細分化出来ないところまで実施する
  4. サブシステムの内部状態と外部との関わり（インターフェース）を規定する
  5. サブシステムと上位システムのインターフェースを規定する
  6. システム間のインターフェースが上手く機能するかチェックする
  7. マクロ側の視点から、全体フローが問題なく流れそうかをチェックする
  8. 納得がいくまで上記ステップを繰り返す

さっぱり意味不明だ･･･と思ったとしても安心して欲しい。

こういったプロセスを上流工程設計と言うが、実はかなりの経験を積まないと適切な設計を行うことは難しい。というのも、上流工程における検討作業は非常に抽象度が高く、システムのデザインパターン・アンチパターンについての知識や、設計文書を作成する技術を習得する必要があるからだ。特に後者については、UML (Unified Modling Language) と呼ばれる表記法を用いることが多い。これを勉強しておけば、複雑なシステムの設計に対しても、自信を持って対応することが出来るようになるだろう。興味がある読者はぜひ調べてみて欲しい。

さて、本題に戻ろう。

ここでは、1群1次元拡散計算コードのシステム設計を行っていく訳だが、どのように考えれば良いのだろうか？　具体的に考えてみよう。

オブジェクト指向分析を行う場合、現実世界をプログラムの世界にある程度直接的にマッピングするという方法が有効だ。もちろん、この方法が唯一の方法ではないが、人間の思考パターンやオブジェクト指向の考え方に沿っているため、直感的に理解しやすいからだ。

---
##### Tips: システム設計で常に意識しておきたいこと
システムを開発する際に重要視すべきことは、大規模になれば大規模になるほど、そのライフサイクルが長くなるという事実だ。これは、保守期間が長くなるということを意味する。そのシステムに自分自身がずっと関わるのであればまだ良いが、多くの場合は将来にわたって複数の人が関与することになる。この際、最も重要視すべきものは、実装中のコメントでも外部のドキュメントでもなく、分かりやすい設計（と実装）自体である。いくらドキュメントが整備され、コメントが詳細に記載されていても、難解な設計だったり「ダメダメな設計」だったとしたら目も当てられない。

ここで言う分かりやすい設計とは、上記で述べたように、直感的に理解できるプログラム構造やオブジェクトクラスへの分割を意味する。あと、忘れてはいけないもう一つの重要なことは、将来の自分は他人と同じであるという事実だ。完璧な記憶を持つ人で無い限り（ほぼ全ての人がそうだろう）、自分が設計した内容であっても時間が経てばその詳細は忘れてしまう。ただし、分かりやすい設計であれば、見た瞬間に理解したり記憶を呼び戻したりするだろう。理想的な設計とは、かくあるべきである。

---

思いっきり脱線してしまったので、再び本題に戻ろう。

今のテーマは拡散方程式を解いて、実効増倍率や中性子束分布を求めることだ。なので、計算体系を定義して、その媒質中における中性子の拡散現象を取り扱う必要がある。

ということで、システムの設計をしなければならないあなたは、次のような考えを巡らすことだろう･･･。

---
##### (あなたの頭の中の声)
取り扱うべき対象は計算体系だから、マクロからミクロに視点をずらしていけば、その本質は、媒質の中で断面積と反応しながら中性子が拡散する･･･ということだな。だったら、中性子や断面積をオブジェクトとして表現すれば良いかな？　ほんでもって、これ以上に分割できそうにないから、これが最も詳細なレベルのサブシステムということで良いかな？　よし、じゃぁ仮に Neutron クラス、CrossSection クラスとすることにしよう。

そしたら、この中性子や断面積といったオブジェクトは、誰がどのようにして取り扱えば良いだろう･･･。今度はミクロ（詳細）なレベルから、マクロな（より上位の）レベルに視点を戻してみよう。

計算機で取り扱うには、特に今回のような決定論的手法だったら、どうしても避けられないのが離散化だよね～。ということは、媒質をメッシュとかノードに分割する必要があるよね。であれば、仮に計算ノードという一単位を作って、この中に中性子や断面積が含まれるとすれば、サブシステムとして都合が良いんじゃないかな？。きっとそうだ。じゃぁ、仮に Node クラスとしておこう。

となると、計算体系というのは計算メッシュの集まり考えたら都合が良いかもしれないな･･･。だったら、Container クラスとして、その内部に Node オブジェクトを管理しておけば良いんじゃないだろうか！？

Container オブジェクトは計算体系を表すから、もしかしたら、詳細メッシュ分割した Container と、粗いメッシュ分割をした Container を別々に準備して、それぞれを上手く作用させたら粗メッシュ拡散加速法とかもうまく実現できるかもしれないな！　どうすれば良いかよく分からんけど、感覚的にはそんな感じかな！？

でも、ちょっと待てよ。Container オブジェクトに計算制御部分も入れるとなると、かなり複雑なシステムになってしまうなぁ。だったら MVC モデルのように、物理量を保持するモデルクラスと実際の挙動を取り仕切る制御クラスと分離して挙げた方がよいかもしれないなぁ。Container クラスを制御するクラスだから ContainerController だな！ 我ながら安直な命名だけど、分かりやすくて良いよね～。Container オブジェクトのインスタンス1つにつき、ContainerController オブジェクトのインスタンスを用意すれば良いね。

じゃぁ、計算全体をマネジメントするのはどうすれば良いかな～。安直だけど、CalclationManager で良いだろう。うん、Simple is best!

さて、今度は全体の流れを考えてみよう。

CalculationManager が Container オブジェクトを作って、ContainerController オブジェクトに渡してあげてから、ContainerController オブジェクトに制御を頼めば良いよね･･･。

Containerオブジェクトが生まれたときに、内部に Node オブジェクトを準備する必要があるな。これには CrossSection オブジェクトが必要かな？　これは計算条件として与えられるとして、これを Node オブジェクトに渡せばいいね。

Container は ContainerController から「計算しろ」と言われたら、Container オブジェクトは内部の Node オブジェクト間で Neutron オブジェクトをやりとりしてから、Node オブジェクトに「計算しろ」と言えばよさそうだな。Node オブジェクトは隣のノードから受け取った入射中性子と、断面積から計算された応答行列を使えば、放出中性子を計算できそうだな･･･。うん、応答行列法を使えば、上手く表現できそうだ。


いや、ちょっとまてよ。

中性子のために Neutron クラスってのを考えたけど、これって必要かな？　**拡散理論の応答行列法なら、中性子流も中性子束も P0成分だけだから、たんなるスカラー量として表現できる**よなぁ。それに、中性子オブジェクトとしたところで、特に振る舞いを規定することもないから、単なる配列とかで良いんじゃね？

---

･･･というような感じで考えただろう（と、いうことにしておこう･･･）

こんな風な思考プロセスを経て、クラス構造をザックリとまとめたのが以下の図だ。

---
+ 断面積（CrossSection）
    - 断面積データの設定・保持
    - 他の断面積との足し算・引き算
    - 中性子束との掛け算
    - スカラー量（体積等）との掛け算
    - 断面積バランスのチェック

+ 計算ノード (Node)
  - 各種物理量の保持
    - 断面積
    - 平均中性子束
  - 各面の部分中性子流(入射及び放出）
  - 部分中性子流のレスポンス計算
  - ノード内の核分裂源の計算

+ 計算体系 (Container)
  - ノードの保持
  - 内側反復の計算
  - 体系内の総核分裂源の計算

+ 計算体系制御 (ContainerController) 
  - 計算体系の保持
  - 内側反復計算の制御

+ 計算全体管理 (CalculationManager)
  - 計算条件の管理
  - 計算体系制御の管理
  - 外側反復計算の制御
  - 加速計算の制御

---


### Step1: 基本的なオブジェクトの設計と実装


### Step2: テストコードを準備する


### Step3: CrossSectionクラスの拡張


### Step4: Nodeクラスの拡張



### Step5: Contaierクラスの新設


### Step6: ContainerControllerクラスの新設


### Step7: CalculationManagerクラスの新設


### Final: 完成


## 2群計算への拡張


## 加速法の実装

### SOR法の実装

